# Problem 67

For this exercise, we will examine the code generated by `GCC` for functions that have
structures as arguments and return values and from this see how these language
features are typically implemented.

The following `C` code has a function `process` having structures as argument
and return values and a function `eval` that calls `process`

```C
typedef struct {
    long a[2];
    long *p;
} strA

typedef struct {
    long u[2];
    long q;
} strB

strB process(strA s) {
    strB r;
    r.u[0] = s.a[1];
    r.u[1] = s.a[0];
    r.q = *s.p;
    return r;
}

long eval(long x, long y, long z) {
    strA s;
    s.a[0] = x;
    s.a[1] = y;
    s.p = &z;
    strB r = process(s);
    return r.u[0] + r.u[1] + r.q;
}
```

`GCC` generates the follow code for these two functions

```asm
# strB process(strA s)
process:
    movq    %rdi, %rax
    movq    24(%rsp), %rdx
    movq    (%rdx), %rdx
    movq    16(%rsp), %rcx
    movq    %rcx, (%rdi)
    movq    8(%rsp), %rcx
    movq    %rcx, 8(%rdi)
    movq    %rdx, 16(%rdi)
    ret

# long eval(long x, long y, long z)
# x in %rdi, y in %rsi, z in %rdx
eval:
    subq    $104, %rsp
    movq    %rdx, 24(%rsp)
    leaq    24(%rsp), %rax
    movq    %rdi, (%rsp)
    movq    %rsi, 8(%rsp)
    movq    %rax, 16(%rsp)
    leaq    64(%rsp), %rdi
    call    process
    movq    72(%rsp), %rax
    addq    64(%rsp), %rax
    addq    80(%rsp), %rax
    addq    $104, %rsp
    ret
```

- (a) We can see on line 2 of function `eval` that it allocates 104 bytes on the stack.
  Diagram the stack frame for eval, showing the values that it stores on the
  stack prior to calling the process.

- (b) What value does `eval` pass in its call to `process`?

- (c) How does the code for `process` access elements of structure argument `s`?

- (d) How does the code for `process` set the fields of result structure `r`?

- (e) Complete your diagram of the stack frame for `eval`, showing how `eval`
  accesses the elements of structure `r` following the return from process.

- (f) What general principles can you discern about how structure values are
  passed as function arguments and how they are returned as function results?

## Answers

### (a)

| Address | State                           |
| :-----: | ------------------------------- |
|   104   |                                 |
|   96    |                                 |
|   88    |                                 |
|   80    |                                 |
|   72    |                                 |
|   64    | <- %rdi (value is this address) |
|   56    |                                 |
|   48    |                                 |
|   40    |                                 |
|   32    |                                 |
|   24    | rdx stored here (z)             |
|   16    | rax stored here (&z)            |
|    8    | rsi stored here (y)             |
|    0    | rdi stored here (x)             |

## (b)

`eval` passes the address of `64 + %rsp` to `process` via `%rdi`

## (c)

`process` accesses elements of argument `s` by `%rsp + offset`

## (d)

`process` sets the fields of structure `r` by `%rdi + offset`

- it returns `%rdi`, the address of the start of `r`

## (e)

| Address | State                                     |
| :-----: | ----------------------------------------- |
|   104   |                                           |
|   96    |                                           |
|   88    |                                           |
|   80    | r.q                                       |
|   72    | r.u[1]                                    |
|   64    | r.u[0]                                    |
|   56    |                                           |
|   48    |                                           |
|   40    |                                           |
|   32    |                                           |
|   24    | rdx stored here (z)                       |
|   16    | rax stored here (&z) (s.p)                |
|    8    | rsi stored here (y) (s.a[1])              |
|    0    | <-%rsp, rdi stored here (x) (&s / s.a[0]) |

```asm
...
call process
movq 72(%rsp), %rax     # r.u[1]
addq 64(%rsp), %rax     # r.u[1] + r.u[0]
addq 80(%rsp), %rax     # r.u[1] + r.u[0] + r.q
addq $104, %rsp
ret
```

## (f)

- The caller passes the start address of a structure argument via registers / stack allocated argument
- The caller also allocates space for the returned structure from the callee
