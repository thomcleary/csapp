# Problem 4

When we us `GCC` to compile `combine3` with command-line option `-O2`, we get
code with substantially better CPE performance than with `-O1`

| Function   | Page | Method                  | + (integer) | \* (integer) | + (floating point) | \* (floating point) |
| ---------- | ---- | ----------------------- | ----------- | ------------ | ------------------ | ------------------- |
| `combine3` | 513  | Compiled `-O1`          | 7.17        | 9.02         | 9.02               | 11.03               |
| `combine3` | 513  | Compiled `-O2`          | 1.60        | 3.01         | 3.01               | 5.01                |
| `combine4` | 513  | Accumulate in temporary | 1.27        | 3.01         | 3.01               | 5.01                |

We achieve performance comparable to that for `combine4` except for the case
of integer sum, but even it improves significantly. On examining the assembly code
generated by the compiler, we find an interesting variant for the inner loop.

```asm
# Inner loop of combine3. data_t = double, OP = *, Compiled -O2
# dest in %rbx, data+i in %rdx, data+length in %rax
# Accumulated product in %xmm0
.L22:
    vmulsd  (%rdx), %xmm0, %xmm0    # Multiply product by data[i]
    addq    $8, %rdx                # Increment data+i
    cmpq    %rax, %rdx              # Compare to data+length
    vmovsd  %xmm0, (%rbx)           # Store product at dest
    jne     .L22                    # if != goto loop
```

We compre this to the version created with optimisation level 1

```asm
.L17:
    vmovsd  (%rbx), %xmm0           # Read product from dest
    vmulsd  (%rdx), %xmm0, %xmm0    # Multiply product by data[i]
    vmovsd  %xmm0, (%rbx)           # Store product at dest
    addq    $8, %rdx                # Increment data+i
    cmpq    %rax, %rdx              # Compare to data+length
    jne     .L17                    # if != goto loop
```

We see that besides some reordering of instructions, the only difference is that
the more optimized version does not contain `vmovsd` implementing the read
from the location designated by dest (line 2)

- (a) How does the role of register `%xmm0` differ in these two loops?

- (b) Will the more optimized version faithfully implement the `C` code of `combine3`,
  including when there is memory aliasing between `dest` and the vector data?

- (c) Either explain why this optimization preserves the desired behaviour, or give
  an exampler where it would product different results that the less optimized version

## Answers

### (a)

- `-O2`
  `%xmm0` is used as an accumulator for the product, but is written back to dest each iteration

- `-O1`
  `%xmm0` is not used as the accumulator for product, it reads from and writes back to dest each iteration

### (b)

vec = [1, 2, 3], dest = vec[2]

- `-O2`
  [1, 2, 3] -> [1, 2, 1] -> [1, 2, 2] -> [1, 2, 4]

- `-O1`
  [1, 2, 3] -> [1, 2, 1] -> [1, 2, 2] -> [1, 2, 4]

Yes it will faithfully implement the `C` code of `combine3` even with memory aliasing

### (c)

Since the `-O2` version writes back to `dest` at the end of each iteration the behaviour
of the less optimized version is preserved.

This simply removes an unecessary read of `dest` by turning `%xmm0` into an accumulator rather
than a temporary variable
